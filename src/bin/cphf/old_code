/**************************************************************************/
/*                                                                        */
/*   CPHF:                                                                */
/*      Written by Edward Seidl (a NON-hog)                               */
/*      October 1990                                                      */
/*      Parts liberally ripped off from HFS group CPXXAOS                 */
/*        codes written in FORTRAN (Boo!!!)                               */
/*      Uses PK  supermatrix on file37                                    */
/*                                                                        */
/**************************************************************************/
/*                                                                        */
/*   Description of input                                                 */
/*                                                                        */
/*   Line 1:  Two integer flags                                           */
/*                                                                        */
/*      1) toler     tolerance for cutoff of integrals                    */
/*                   0 default pow(10.0,-12)                              */
/*                   n pow(10.0,-toler)                                   */
/*      2) print     printing option                                      */
/*      3) master    if 0 do not create master file, else create file40   */
/*                                                                        */
/**************************************************************************/

#include "includes.h"
#include "common.h"


void main()
   {
      int i,j,ij;
      int ierr,degen=0;
      double *temp;

      itap37 = 37;
      itap42 = 42;
      itap43 = 43;
      itap44 = 44;

      rfile(itap37);
      rfile(itap42);
      rfile(itap43);
      rfile(itap44);

      ffile(&infile,"input.dat",2);
      ffile(&outfile,"output.dat",0);

      tstart(outfile);

      fprintf(outfile,"\n\tCPHF: A General cphf code in ao basis\n\n");

      ierr = io_locate(infile,"# CPHFAO #");
      if (!ierr) fscanf(infile," %d %d %d %d %d %d",&etest,&iorb,&dipole,
                                                     &conv,&core,&print);
      else {
         etest = 0;
         iorb = 0;
         dipole = 0;
         conv = 12;
         core = 0;
         print = 0;
         }
      if(!conv) conv=12;

      ioff[0] = 0;
      for (i = 1; i < 1024 ; i++) {
         ioff[i] = ioff[i-1] + i;
         }

      init_master();

      fprintf(outfile,"\n\n\tnbasis = %5d\n",nbasis);
      fprintf(outfile,"\tntri   = %5d\n",ntri);
      fprintf(outfile,"\tnatom  = %5d\n",natom);
      fprintf(outfile,"\tiopen  = %5d\n",iopen);
      fprintf(outfile,"\tetest  = %5d\n",etest);
      fprintf(outfile,"\tiorb   = %5d\n",iorb);
      fprintf(outfile,"\tdipole = %5d\n",dipole);
      fprintf(outfile,"\tconv   = %5d\n",conv);
      fprintf(outfile,"\tcore   = %5d\n",core);
      fprintf(outfile,"\tprint  = %5d\n",print);
      fprintf(outfile,"\tnind   = %5d\n",nind);
      fprintf(outfile,"\tndep   = %5d\n",ndep);

      fprintf(outfile,"\n\tnuclear repulsion energy = %20.10f\n",enuc);
      fprintf(outfile,"\tscf energy               = %20.10f\n\n",escf);

      if(iopen) fprintf(outfile,"\tcalculation for open shell system\n");
      else fprintf(outfile,"\tcalculation for closed shell system\n");

/* read in ao and so eigenvectors and eigenvalues and occ numbers */

      temp = (double *) init_array(nbasis*nbasis);
      e_vals = (double *) init_array(nbasis);
      occ_num = (double *) init_array(nbasis);
      e_vecs_ao = (double **) init_matrix(nbasis,nbasis);
      e_vecs_so = (double **) init_matrix(nbasis,nbasis);

      mread(e_vals,16);
      mread(occ_num,17);

      mread(temp,18);
      for(i=ij=0; i < nbasis ; i++) 
         for(j=0; j < nbasis ; j++)
            e_vecs_so[j][i] = temp[ij++];

      mread(temp,19);
      for(i=ij=0; i < nbasis ; i++) 
         for(j=0; j < nbasis ; j++)
            e_vecs_ao[j][i] = temp[ij++];

      free(temp);

      if(print > 1) {
         fprintf(outfile,"\n ao eigenvector, eigenvalues, and occupations\n");
         eigout(e_vecs_ao,e_vals,occ_num,nbasis,nbasis,outfile);

         fprintf(outfile,"\n so eigenvector, eigenvalues, and occupations\n");
         eigout(e_vecs_so,e_vals,occ_num,nbasis,nbasis,outfile);

         if(iopen) {
            fprintf(outfile,"\n alpa matrix\n");
            print_mat(alpa,ntype1,ntype1,outfile);

            fprintf(outfile,"\n beta matrix\n");
            print_mat(beta,ntype1,ntype1,outfile);
            }
         }

      make_vec();

/* read in derivatives from file42 and transform to mo basis */

      rfile(91);
#if !STOP
      derivs();

/* calculate scf energy and derivatives as a test */

      if(etest) {
         test_energy();
         test_deriv();
         }

/* form derivative lagrangian matrix */

      if(iopen) famat_o();
      else famat_c();

/* calculate ba matrix for independent pairs */

      if(iopen) bamat_o();
      else bamat();
      fflush(outfile);

/* bf matrix for dipole stuff */

      if(dipole) bfmat();
#endif

/* do the cphf iterations */

      cphf_iter();

/* u matrix stuff */

      if(!iopen) degen = ucmat();
      uxmat();

      if(iopen) wamat();

/* calculate scf second derivatives */

      if(iopen) scf2nd_o();
      else if(degen) scf2nd_d();
           else scf2nd();

/* dipole stuff */

      if(!degen) dipmo();
      else dipmo_d();

      if(!iopen && iorb) {
         orb1st(1);
         if(dipole) orb1st(2);
         }

      if(dipole) polar();

      rclose(itap37,3);
      rclose(itap40,3);
      rclose(itap42,3);
      rclose(itap43,3);
      rclose(itap44,3);
      rclose(work,4);
      tstop(outfile);
      }
#define EXTERN
#include "includes.h"
#include "common.h"

dipmo()

   {
      int i,j,ij,ix;
      int i00,ixx,iyy,izz,kabc,iabc;
      int p1,p2;
      double debye=2.541765480;
      double bohr=0.52917706;
      double deb4 = 4.0*debye;
      double rbohr = 1.0/bohr;
      double f;
      double **dip,***ua;
      double **dipda,**dipdm,**dipdt,**dipde,**dipdn;
      double *temp,*tmp2;
      FILE *itap17;

      ffile(&itap17,"file17.dat",0);

      dip = (double **) init_matrix(3,ntri);
      dipda = (double **) init_matrix(3,135);
      dipdm = (double **) init_matrix(3,135);
      dipdn = (double **) init_matrix(3,135);
      dipde = (double **) init_matrix(3,135);
      dipdt = (double **) init_matrix(3,135);
      ua = (double ***) malloc(sizeof(double **)*3);
      for(i=0; i < 3 ; i++) ua[i] = (double **) init_matrix(nbasis,nbasis);

      temp = (double *) init_array(135);
      tmp2 = (double *) init_array(nbasis*nbasis*natom);

      srew(itap43);

      sread(itap43,temp,sizeof(double)*135);
      for(i=ij=0; i < 135 ; i++)
         for(j=0; j < 3 ; j++)
            dipda[j][i] = temp[ij++];

      sread(itap43,temp,sizeof(double)*135);
      for(i=ij=0; i < 135 ; i++)
         for(j=0; j < 3 ; j++)
            dipdn[j][i] = temp[ij++];

      srew(itap44);

      for(ix=0; ix < 3 ; ix++)
         rread(itap44,dip[ix],sizeof(double)*ntri,ha_loc[natom3+ix]);

      for(iabc=kabc=0; iabc < natom ; iabc++) {
         i00=iabc*3;
         ixx=i00;
         iyy=i00+1;
         izz=i00+2;     

         for(ix=0; ix < 3 ; ix++) {
            rread(itap44,tmp2,sizeof(double)*nbasis*nbasis,ua_loc[kabc++]);
            for(i=ij=0; i < nbasis ; i++)
               for(j=0; j < nbasis ; j++)
                  ua[ix][j][i] = tmp2[ij++];
            }

         for(i=0; i < nocc ; i++) {
            f = occ_num[i]*0.5;
            for(j=0; j < nbasis ; j++) {
               p1=MAX0(i,j);
               p2=MIN0(i,j);
               ij=ioff[p1]+p2;
               dipdm[0][ixx] += ua[0][j][i]*dip[0][ij]*f;
               dipdm[0][iyy] += ua[1][j][i]*dip[0][ij]*f;
               dipdm[0][izz] += ua[2][j][i]*dip[0][ij]*f;
               dipdm[1][ixx] += ua[0][j][i]*dip[1][ij]*f;
               dipdm[1][iyy] += ua[1][j][i]*dip[1][ij]*f;
               dipdm[1][izz] += ua[2][j][i]*dip[1][ij]*f;
               dipdm[2][ixx] += ua[0][j][i]*dip[2][ij]*f;
               dipdm[2][iyy] += ua[1][j][i]*dip[2][ij]*f;
               dipdm[2][izz] += ua[2][j][i]*dip[2][ij]*f;
               }
            }
         }

      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipdm[i][j] *= -deb4;

      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipde[i][j] = dipda[i][j]+dipdm[i][j];

      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipdt[i][j] = dipde[i][j]+dipdn[i][j];
     
      fprintf(outfile,"\n first derivatives of dipole moments (debye/bohr)\n");
      print_mat(dipdt,3,natom3,outfile);
     
      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipdt[i][j] *= rbohr;
     
      fprintf(outfile,"\n first derivatives of dipole moments (debye/a)\n");
      print_mat(dipdt,3,natom3,outfile);

      fprintf(itap17,"%5d%5d\n",natom,natom3);
      for(i=ij=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            tmp2[ij++] = dipdt[i][j];
      for(ij=0; ij < natom3*3 ; ij += 3)
         fprintf(itap17,"%20.10f%20.10f%20.10f\n",tmp2[ij],tmp2[ij+1],tmp2[ij+2]);

      rewind(itap17);
      fclose(itap17);
      }

#define EXTERN
#include "includes.h"
#include "common.h"

dipmo_d()

   {
      int i,j,ij,ix;
      int i00,ixx,iyy,izz,kabc,iabc;
      int p1,p2;
      double debye=2.541765480;
      double bohr=0.52917706;
      double deb4 = 4.0*debye;
      double rbohr = 1.0/bohr;
      double f;
      double **dip,***ua,**sa;
      double **dipda,**dipdm,**dipdt,**dipde,**dipdn;
      double *temp,*tmp2;
      FILE *itap17;

      ffile(&itap17,"file17.dat",0);

      dip = (double **) init_matrix(3,ntri);
      sa = (double **) init_matrix(3,ntri);
      dipda = (double **) init_matrix(3,135);
      dipdm = (double **) init_matrix(3,135);
      dipdn = (double **) init_matrix(3,135);
      dipde = (double **) init_matrix(3,135);
      dipdt = (double **) init_matrix(3,135);
      ua = (double ***) malloc(sizeof(double **)*3);
      for(i=0; i < 3 ; i++) ua[i] = (double **) init_matrix(nbasis,nbasis);

      temp = (double *) init_array(135);
      tmp2 = (double *) init_array(nbasis*nbasis*natom);

      srew(itap43);

      sread(itap43,temp,sizeof(double)*135);
      for(i=ij=0; i < 135 ; i++)
         for(j=0; j < 3 ; j++)
            dipda[j][i] = temp[ij++];

      sread(itap43,temp,sizeof(double)*135);
      for(i=ij=0; i < 135 ; i++)
         for(j=0; j < 3 ; j++)
            dipdn[j][i] = temp[ij++];

      srew(itap44);

      for(ix=0; ix < 3 ; ix++)
         rread(itap44,dip[ix],sizeof(double)*ntri,ha_loc[natom3+ix]);

      for(iabc=kabc=0; iabc < natom ; iabc++) {
         i00=iabc*3;
         ixx=i00;
         iyy=i00+1;
         izz=i00+2;     

         for(ix=0; ix < 3 ; ix++,kabc++) {
            rread(itap44,sa[ix],sizeof(double)*ntri,sa_loc[kabc]);
            rread(itap44,tmp2,sizeof(double)*nbasis*nbasis,ua_loc[kabc]);
            for(i=ij=0; i < nbasis ; i++)
               for(j=0; j < nbasis ; j++)
                  ua[ix][j][i] = tmp2[ij++];
            }

         for(i=0; i < nc ; i++) {
            f = 0.5;
            for(j=0; j < nc ; j++) {
               p1=MAX0(i,j);
               p2=MIN0(i,j);
               ij=ioff[p1]+p2;
               dipdm[0][ixx] -= sa[0][ij]*dip[0][ij]*f;
               dipdm[0][iyy] -= sa[1][ij]*dip[0][ij]*f;
               dipdm[0][izz] -= sa[2][ij]*dip[0][ij]*f;
               dipdm[1][ixx] -= sa[0][ij]*dip[1][ij]*f;
               dipdm[1][iyy] -= sa[1][ij]*dip[1][ij]*f;
               dipdm[1][izz] -= sa[2][ij]*dip[1][ij]*f;
               dipdm[2][ixx] -= sa[0][ij]*dip[2][ij]*f;
               dipdm[2][iyy] -= sa[1][ij]*dip[2][ij]*f;
               dipdm[2][izz] -= sa[2][ij]*dip[2][ij]*f;
               }
            for(j=nc; j < nbasis ; j++) {
               p1=MAX0(i,j);
               p2=MIN0(i,j);
               ij=ioff[p1]+p2;
               dipdm[0][ixx] += ua[0][j][i]*dip[0][ij];
               dipdm[0][iyy] += ua[1][j][i]*dip[0][ij];
               dipdm[0][izz] += ua[2][j][i]*dip[0][ij];
               dipdm[1][ixx] += ua[0][j][i]*dip[1][ij];
               dipdm[1][iyy] += ua[1][j][i]*dip[1][ij];
               dipdm[1][izz] += ua[2][j][i]*dip[1][ij];
               dipdm[2][ixx] += ua[0][j][i]*dip[2][ij];
               dipdm[2][iyy] += ua[1][j][i]*dip[2][ij];
               dipdm[2][izz] += ua[2][j][i]*dip[2][ij];
               }
            }
         }

      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipdm[i][j] *= -deb4;

      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipde[i][j] = dipda[i][j]+dipdm[i][j];

      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipdt[i][j] = dipde[i][j]+dipdn[i][j];
     
      fprintf(outfile,"\n first derivatives of dipole moments (debye/bohr)\n");
      print_mat(dipdt,3,natom3,outfile);
     
      for(i=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            dipdt[i][j] *= rbohr;
     
      fprintf(outfile,"\n first derivatives of dipole moments (debye/a)\n");
      print_mat(dipdt,3,natom3,outfile);

      fprintf(itap17,"%5d%5d\n",natom,natom3);
      for(i=ij=0; i < 3 ; i++)
         for(j=0; j < natom3 ; j++)
            tmp2[ij++] = dipdt[i][j];
      for(ij=0; ij < natom3*3 ; ij += 3)
         fprintf(itap17,"%20.10f%20.10f%20.10f\n",tmp2[ij],tmp2[ij+1],tmp2[ij+2]);

      rewind(itap17);
      fclose(itap17);
      }

#define EXTERN
#include "includes.h"
#include "common.h"

orb1st(flag)
   int flag;
 
   {
      int iabc,i,ii;
      double *b0,**cc;

      b0 = (double *) init_array(ntri);
 
      switch(flag) {
         case 1:
            cc = (double **) init_matrix(nbasis,natom3);

            srew(itap44);
            for(iabc=0; iabc < natom3 ; iabc++) {
               rread(itap44,b0,sizeof(double)*ntri,ba_loc[iabc]);
               for(i=0; i < nbasis ; i++) {
                  ii=ioff[i]+i;
                  cc[i][iabc]=b0[ii];
                  }
               }
         
            fprintf(outfile,
                "\n first derivatives of orbital energies wrt nuclear coordinate\n");
            print_mat(cc,nbasis,natom3,outfile);

            free(b0);
            free_matrix(cc,nbasis);
            break;

         case 2:
            cc = (double **) init_matrix(nbasis,3);
            srew(itap44);

            for(iabc=0; iabc < 3 ; iabc++) {
               rread(itap44,b0,sizeof(double)*ntri,ba_loc[iabc+natom3]);
               for(i=0; i < nbasis ; i++) {
                  ii=ioff[i]+i;
                  cc[i][iabc]=b0[ii];
                  }
               }

            fprintf(outfile,
                "\n first derivatives of orbital energies wrt electric field\n");
            print_mat(cc,nbasis,3,outfile);

            free(b0);
            free_matrix(cc,nbasis);
            break;
         }
      }

#define EXTERN
#include "includes.h"
#include "common.h"

scf2nd()
   {
      int i,iabc,jabc,ij,p1,p2,j,ii;
      double vp,vm;
      double f;
      double **sa,**fa,*temp,**e2p,**e2m,**e2a;
      double *ba,**ua;
      FILE *itap15;

      ffile(&itap15,"file15.dat",0);

      sa = (double **) init_matrix(natom3,ntri);
      fa = (double **) init_matrix(natom3,ntri);
      ba = (double *) init_array(ntri);
      e2p = (double **) init_matrix(natom3,natom3);
      e2m = (double **) init_matrix(natom3,natom3);
      e2a = (double **) init_matrix(natom3,natom3);
      ua = (double **) init_matrix(nbasis,nbasis);
      temp = (double *) init_array(nbasis*nbasis*natom);

      srew(itap44);
      srew(itap42);

      sread(itap42,temp,sizeof(double)*natom3);
      sread(itap42,temp,sizeof(double)*natom3*natom3);
      for(i=ij=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            e2a[j][i] = temp[ij++];

      for(iabc=0; iabc < natom3 ; iabc++) {
         rread(itap44,sa[iabc],sizeof(double)*ntri,sa_loc[iabc]);
         rread(itap44,fa[iabc],sizeof(double)*ntri,fa_loc[iabc]);
         }

      for(iabc=0; iabc < natom3 ; iabc++) {
         rread(itap44,temp,sizeof(double)*nbasis*nbasis,ua_loc[iabc]);
         rread(itap44,ba,sizeof(double)*ntri,ba_loc[iabc]);
         for(i=ij=0; i < nbasis ; i++)
            for(j=0; j < nbasis ; j++)
               ua[j][i]=temp[ij++];

         for(jabc=0; jabc < natom3 ; jabc++) {
            vp=vm=0.0;
            for(i=0; i < nocc ; i++) {
               ii=ioff[i]+i;
               vm -= ba[ii]*sa[jabc][ii]*0.5;
               for(j=0; j < nbasis ; j++) {
                  p1=MAX0(i,j);
                  p2=MIN0(i,j);
                  ij=ioff[p1]+p2;
                  f = fa[jabc][ij]-e_vals[i]*sa[jabc][ij];
                  vp += f*ua[j][i];
                  }
               }
            e2m[iabc][jabc] = vm*4.0;
            e2p[iabc][jabc] = vp*4.0;
            }
         }

      if(print > 0) {
         fprintf(outfile,"\n e2p matrix\n");
         print_mat(e2p,natom3,natom3,outfile);
         fprintf(outfile,"\n e2m matrix\n");
         print_mat(e2m,natom3,natom3,outfile);
         }

      for(i=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            e2m[i][j] += e2p[i][j];

      fprintf(outfile,"\n\tsummary of first order cphf calculation\n");

#if 0
      fprintf(outfile,"\n e2a matrix\n");
      print_mat(e2a,natom3,natom3,outfile);
      fprintf(outfile,"\n e2m matrix\n");
      print_mat(e2m,natom3,natom3,outfile);
#endif

      for(i=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            e2m[i][j] += e2a[i][j];

      fprintf(outfile,"\n scf second derivative matrix\n");
      print_mat(e2m,natom3,natom3,outfile);

      fprintf(itap15,"%5d%5d\n",natom,natom3*2);
      for(i=ij=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            temp[ij++] = e2m[j][i];
      for(ij=0; ij < natom3*natom3 ; ij += 3)
         fprintf(itap15,"%20.10f%20.10f%20.10f\n",temp[ij],temp[ij+1],temp[ij+2]);

      rewind(itap15);
      fclose(itap15);

      free(temp);
      free(ba);
      free_matrix(sa,natom3);
      free_matrix(fa,natom3);
      free_matrix(e2p,natom3);
      free_matrix(e2m,natom3);
      free_matrix(e2a,natom3);
      free_matrix(ua,nbasis);
      }
#define EXTERN
#include "includes.h"
#include "common.h"

scf2nd_d()
   {
      int i,iabc,jabc,ij,p1,p2,j;
      int num,ilast,kl;
      double vp,vm,vq,vr;
      double pval;
      double **sa,**fa,*temp,**e2p,**e2q,**e2r,**e2m,**e2a;
      double **scr1,**scr2;
      double **dp,**dm;
      double **ua;
      FILE *itap15;

      ffile(&itap15,"file15.dat",0);

      sa = (double **) init_matrix(natom3,ntri);
      fa = (double **) init_matrix(natom3,ntri);
      dp = (double **) init_matrix(natom3,ntri);
      dm = (double **) init_matrix(natom3,ntri);
      e2p = (double **) init_matrix(natom3,natom3);
      e2q = (double **) init_matrix(natom3,natom3);
      e2r = (double **) init_matrix(natom3,natom3);
      e2m = (double **) init_matrix(natom3,natom3);
      e2a = (double **) init_matrix(natom3,natom3);
      ua = (double **) init_matrix(nbasis,nbasis);
      scr1 = (double **) init_matrix(nbasis,nbasis);
      scr2 = (double **) init_matrix(nbasis,nbasis);
      temp = (double *) init_array(nbasis*nbasis*natom);

      srew(itap44);
      srew(itap42);

      sread(itap42,temp,sizeof(double)*natom3);
      sread(itap42,temp,sizeof(double)*natom3*natom3);
      for(i=ij=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            e2a[j][i] = temp[ij++];

      for(iabc=0; iabc < natom3 ; iabc++) {
         rread(itap44,sa[iabc],sizeof(double)*ntri,sa_loc[iabc]);
         rread(itap44,fa[iabc],sizeof(double)*ntri,fa_loc[iabc]);
         }

      densmatg(dp,sa,ua,temp);

/* for half-transformed density matrix */

      srew(itap37);

      do {
         sread(itap37,c_pkbuf,sizeof(struct c_pkints)*maxbuf);
         num = (c_pkbuf[0].ij % (maxbuf+1));
         ilast = c_pkbuf[0].kl % (maxbuf+1);
         c_pkbuf[0].ij /= (maxbuf+1);
         c_pkbuf[0].kl /= (maxbuf+1);

         for (i=0; i < num ; i++) {
            ij = c_pkbuf[i].ij;
            kl = c_pkbuf[i].kl;
            pval = c_pkbuf[i].pval;

            for(iabc=0; iabc < natom3 ; iabc++) {
               dm[iabc][ij] += dp[iabc][kl]*pval;
               dm[iabc][kl] += dp[iabc][ij]*pval;
               }
            }
         } while(!ilast);

      if(print > 2) {
         for(iabc=0; iabc < natom3 ; iabc++) {
            fprintf(outfile,"\ndenm iabc = %5d\n",iabc);
            print_array(dm[iabc],nbasis,outfile);
            }
         }

      for(iabc=0; iabc < natom3 ; iabc++)
         ao_to_mo(dm[iabc],scr1,e_vecs_so,scr2,nbasis);


      for(iabc=0; iabc < natom3 ; iabc++) {
         for(jabc=0; jabc < natom3 ; jabc++) {
            vm=0.0;
            for(i=0; i < nc ; i++) {
               for(j=0; j < nc ; j++) {
                  p1=MAX0(i,j);
                  p2=MIN0(i,j);
                  ij=ioff[p1]+p2;
                  vm += sa[jabc][ij]*dm[iabc][ij];
                  }
               }
            e2m[iabc][jabc] = vm*2.0;
            }
         }

      for(iabc=0; iabc < natom3 ; iabc++) {
         rread(itap44,temp,sizeof(double)*nbasis*nbasis,ua_loc[iabc]);
         for(i=ij=0; i < nbasis ; i++)
            for(j=0; j < nbasis ; j++)
               ua[j][i]=temp[ij++];
         for(jabc=0; jabc < natom3 ; jabc++) {
            vp=vq=vr=0.0;
            for(i=0; i < nocc ; i++) {
               for(j=0; j < nocc ; j++) {
                  p1=MAX0(i,j);
                  p2=MIN0(i,j);
                  ij=ioff[p1]+p2;
                  vp -= (sa[jabc][ij]*fa[iabc][ij]+sa[iabc][ij]*fa[jabc][ij]);
                  vq += sa[jabc][ij]*sa[iabc][ij]*(3.0*e_vals[i]+e_vals[j]);
                  }
               for(j=nc; j < nbasis ; j++) {
                  p1=MAX0(i,j);
                  p2=MIN0(i,j);
                  ij=ioff[p1]+p2;
                  vr += ua[j][i]*(fa[jabc][ij]-e_vals[i]*sa[jabc][ij]);
                  }
               }
            e2p[iabc][jabc] = 2.0*vp;
            e2q[iabc][jabc] = vq;
            e2r[iabc][jabc] = 4.0*vr;
            }
         }

      if(print > 2) {
         fprintf(outfile,"\n e2p matrix\n");
         print_mat(e2p,natom3,natom3,outfile);
         fprintf(outfile,"\n e2q matrix\n");
         print_mat(e2q,natom3,natom3,outfile);
         fprintf(outfile,"\n e2r matrix\n");
         print_mat(e2r,natom3,natom3,outfile);
         fprintf(outfile,"\n e2m matrix\n");
         print_mat(e2m,natom3,natom3,outfile);
         }

      for(i=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            e2m[i][j] += e2p[i][j]+e2q[i][j]+e2r[i][j];

      fprintf(outfile,"\n\tsummary of first order cphf calculation\n");

#if 0
      fprintf(outfile,"\n e2a matrix\n");
      print_mat(e2a,natom3,natom3,outfile);
      fprintf(outfile,"\n e2m matrix\n");
      print_mat(e2m,natom3,natom3,outfile);
#endif

      for(i=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            e2m[i][j] += e2a[i][j];

      fprintf(outfile,"\n scf second derivative matrix\n");
      print_mat(e2m,natom3,natom3,outfile);

      fprintf(itap15,"%5d%5d\n",natom,natom3*2);
      for(i=ij=0; i < natom3 ; i++)
         for(j=0; j < natom3 ; j++)
            temp[ij++] = e2m[j][i];
      for(ij=0; ij < natom3*natom3 ; ij += 3)
         fprintf(itap15,"%20.10f%20.10f%20.10f\n",temp[ij],temp[ij+1],temp[ij+2]);

      rewind(itap15);
      fclose(itap15);

      free(temp);
      free_matrix(sa,natom3);
      free_matrix(fa,natom3);
      free_matrix(e2p,natom3);
      free_matrix(e2r,natom3);
      free_matrix(e2q,natom3);
      free_matrix(e2m,natom3);
      free_matrix(e2a,natom3);
      free_matrix(dm,natom3);
      free_matrix(dp,natom3);
      free_matrix(ua,nbasis);
      free_matrix(scr1,nbasis);
      free_matrix(scr2,nbasis);
      }
#define EXTERN
#include "includes.h"
#include "common.h"

densmatg(dp,sa,u,temp)
   double **dp,**u,**sa,*temp;

   {
      int i,j,ij,k,l,kl;
      int p1,p2,iabc;
      double esik,esjk,f;
      double *esi,*esj;
      double *esil,*esjl;
      double *dpt,*sat,*ut;
      
      for(iabc=0; iabc < natom3 ; iabc++) {
         dpt = dp[iabc];
         sat = sa[iabc];
         rread(itap44,temp,sizeof(double)*nbasis*nbasis,ua_loc[iabc]);
         for(i=ij=0; i < nbasis ; i++)
            for(j=0; j < nbasis ; j++)
               u[j][i]=temp[ij++];

         for(i=0; i < nbasis ; i++) {
            esi = e_vecs_so[i];
            for(j=0; j <= i ; j++,dpt++) {
               esj = e_vecs_so[j];
               for(k=0; k < nc ; k++) {
                  esik = 2.0*esi[k];
                  for(l=0; l < nc ; l++) {
                     p1=MAX0(k,l);
                     p2=MIN0(k,l);
                     kl = ioff[p1]+p2;
                     f = esik*esj[l];
                     if(f) *dpt += sat[kl]*f;
                     }
                  }
               for(k=nc; k < nbasis ; k++) {
                  esik = esi[k];
                  esjk = esj[k];
                  esil = esi;
                  esjl = esj;
                  ut = u[k];
                  for(l=nc; l ; l--,esjl++,esil++,ut++) {
                     f = *esjl*esik + *esil*esjk;
                     if(f) *dpt -= *ut*f*2.0;
                     }
                  }
               }
            }

         for(i=ij=0; i < nbasis ; i++)
            for(j=0; j <= i ; j++,ij++)
               dp[iabc][ij] = (i == j) ? dp[iabc][ij] : 2.0*dp[iabc][ij];

         if(print > 4) {
            fprintf(outfile,"\ndenp in densmatg iabc = %5d\n",iabc);
            print_array(dp[iabc],nbasis,outfile);
            }
         }
      }
#define EXTERN
#include "includes.h"
#include "common.h"

test_deriv()

   {
      int i,j,ij;
      int p1,p2,p3;
      double *lag_mo,***two_mo,*s_mo,*h_mo;
      double *der1e,*derso,*der2e,*dert;
      double **temp;
      double val;

      lag_mo = (double *) init_array(ntri);
      s_mo = (double *) init_array(ntri);
      h_mo = (double *) init_array(ntri);
      der1e = (double *) init_array(natom3);
      der2e = (double *) init_array(natom3);
      derso = (double *) init_array(natom3);
      dert = (double *) init_array(natom3);
      temp = (double **) init_matrix(3,natom);

      two_mo = (double ***) malloc(sizeof(double **)*ntypes);
      for(i=0; i < ntypes ; i++)
         two_mo[i] = (double **) init_matrix(natom3,ntri);

/* get lagrangian */

      mread(lag_mo,24);
      if(print > 2) {
         fprintf(outfile,"\nmo lagrangian\n");
         print_array(lag_mo,nbasis,outfile);
         }

/* read in 2 electron mo matrices */

      srew(work);
      for(i=0; i < ntypes ; i++)
         for(j=0; j < natom3 ; j++)
            sread(work,two_mo[i][j],sizeof(double)*ntri);

/* and do the work */

      srew(itap44);
      for(i=0; i < natom3 ; i++) {
         rread(itap44,s_mo,sizeof(double)*ntri,sa_loc[i]);
         rread(itap44,h_mo,sizeof(double)*ntri,ha_loc[i]);

    /* one electron contribution */
         for(j=0,val=0.0; j < nocc ; j++) 
            val += occ_num[j]*h_mo[ioff[j]+j];

         der1e[i] = val;
    /* two electron contribution */
         for(j=0,val=0.0; j < ntypes ; j++) 
            for(ij=nstart[j]; ij < nend[j] ; ij++) 
               val += two_mo[j][i][ioff[ij]+ij];

         der2e[i] = val;
    /* overlap contribution */
         for(j=0,val=0.0; j < nocc ; j++) 
            for(ij=0; ij < nocc ; ij++) {
               p1 = MAX0(j,ij);
               p2 = MIN0(j,ij);
               p3 = ioff[p1]+p2;
               val -= lag_mo[p3]*s_mo[p3];
               }

         derso[i] = (iopen) ? 2.0*val : val;

     /* sum contributions */
         dert[i] = der1e[i]+der2e[i]+derso[i];
         }

      for(i=ij=0; i < natom ; i++)
         for(j=0; j < 3 ; j++)
            temp[j][i] = der1e[ij++];
      fprintf(outfile,"\none electron derivatives\n");
      print_mat(temp,3,natom,outfile);

      for(i=ij=0; i < natom ; i++)
         for(j=0; j < 3 ; j++)
            temp[j][i] = derso[ij++];
      fprintf(outfile,"\noverlap derivatives\n");
      print_mat(temp,3,natom,outfile);

      for(i=ij=0; i < natom ; i++)
         for(j=0; j < 3 ; j++)
            temp[j][i] = der2e[ij++];
      fprintf(outfile,"\ntwo electron derivatives\n");
      print_mat(temp,3,natom,outfile);

      for(i=ij=0; i < natom ; i++)
         for(j=0; j < 3 ; j++)
            temp[j][i] = dert[ij++];
      fprintf(outfile,"\ntotal first derivatives\n");
      print_mat(temp,3,natom,outfile);
      fflush(outfile);

      srew(itap44);
      srew(work);
      
      free(lag_mo);
      free(s_mo);
      free(h_mo);
      free(der1e);
      free(der2e);
      free(derso);
      free(dert);
      free_matrix(temp,3);
      for(i=0; i < ntypes ; i++)
         free_matrix(two_mo[i],natom3);
      free(two_mo);
      }
#define EXTERN
#include "includes.h"
#include "common.h"

test_energy()
   {
      int i,j,ij,kl;
      int itap31=31;
      int ilast,num;
      double jval,kval;
      double elec1,elec2,etot,elec;
      double *temp;
      double **hso,**temp2;
      double **denp,**denq,**denm;

      fprintf(outfile,"\n scf energy will be calculated as a test\n");

      temp = (double *) init_array(ntri);
      hso = (double **) init_matrix(nbasis,nbasis);
      temp2 = (double **) init_matrix(nbasis,nbasis);
      denp = (double **) init_matrix(ntypes,ntri);
      denq = (double **) init_matrix(ntypes,ntri);
      denm = (double **) init_matrix(ntypes,ntri);

/* read in one electron integrals in so basis and transform to mo */

      mread(temp,14);

      if(print > 2) {
         fprintf(outfile,"\n hso \n");
         print_array(temp,nbasis,outfile);
         }

      ao_to_mo(temp,hso,e_vecs_so,temp2,nbasis);

      if(print > 2) {
         fprintf(outfile,"\n hmo \n");
         print_array(temp,nbasis,outfile);
         }

      for(i=0,elec1=0.0; i < nocc ; i++)
         elec1 += occ_num[i]*temp[ioff[i]+i];

/* grab density matrices from file31 */

      rfile(itap31);

      switch(ntypes) {
         case 1:
            sread(itap31,denp[0],sizeof(double)*ntri);
            if(print > 2) {
               fprintf(outfile,"\ndenp so basis\n");
               print_array(denp[0],nbasis,outfile);
               }
            break;
         case 2:
            sread(itap31,denp[0],sizeof(double)*ntri);
            sread(itap31,denp[0],sizeof(double)*ntri);
            for(i=0; i < ntypes ; i++) {
               sread(itap31,denp[i],sizeof(double)*ntri);
               sread(itap31,denq[i],sizeof(double)*ntri);
               if(print > 2) {
                  fprintf(outfile,"\ndenp so basis i = %5d\n",i);
                  print_array(denp[i],nbasis,outfile);
                  fprintf(outfile,"\ndenq so basis i = %5d\n",i);
                  print_array(denq[i],nbasis,outfile);
                  }
               }
            break;
         case 3:
            sread(itap31,denp[0],sizeof(double)*ntri);
            sread(itap31,denp[0],sizeof(double)*ntri);
            for(i=0; i < ntypes ; i++) {
               sread(itap31,denp[i],sizeof(double)*ntri);
               sread(itap31,denq[i],sizeof(double)*ntri);
               if(print > 2) {
                  fprintf(outfile,"\ndenp so basis i = %5d\n",i);
                  print_array(denp[i],nbasis,outfile);
                  fprintf(outfile,"\ndenq so basis i = %5d\n",i);
                  print_array(denq[i],nbasis,outfile);
                  }
               }
            break;
         }

/* and calculate two electron part of fock matrix */

      srew(itap37);

      do {
         if(iopen) {
            sread(itap37,o_pkbuf,sizeof(struct o_pkints)*maxbuf);
            num = (o_pkbuf[0].ij % (maxbuf+1));
            ilast = o_pkbuf[0].kl % (maxbuf+1);
            o_pkbuf[0].ij /= (maxbuf+1);
            o_pkbuf[0].kl /= (maxbuf+1);

            for (i=0; i < num ; i++) {
               ij = o_pkbuf[i].ij;
               kl = o_pkbuf[i].kl;
               kval = 0.5*o_pkbuf[i].kval;
               jval = o_pkbuf[i].pval-kval;

               denm[0][ij] += denp[0][kl]*jval;
               denm[0][kl] += denp[0][ij]*jval;     
               for(j=1; j < ntypes ; j++) {
                  denm[j][ij] += denp[j][kl]*jval-denq[j][kl]*kval;
                  denm[j][kl] += denp[j][ij]*jval-denq[j][ij]*kval;
                  }
               }
            }
         else {
            sread(itap37,c_pkbuf,sizeof(struct c_pkints)*maxbuf);
            num = (c_pkbuf[0].ij % (maxbuf+1));
            ilast = c_pkbuf[0].kl % (maxbuf+1);
            c_pkbuf[0].ij /= (maxbuf+1);
            c_pkbuf[0].kl /= (maxbuf+1);

            for (i=0; i < num ; i++) {
               ij = c_pkbuf[i].ij;
               kl = c_pkbuf[i].kl;
               jval = c_pkbuf[i].pval;

               denm[0][ij] += denp[0][kl]*jval;
               denm[0][kl] += denp[0][ij]*jval;     
               }
            }
         } while(!ilast);


      if(print > 2) {
         for(i=0; i < ntypes ; i++) {
            fprintf(outfile,"\ndenm so basis i = %5d\n",i);
            print_array(denm[i],nbasis,outfile);
            }
         }

      for(i=0,elec2=0.0; i < ntypes ; i++) {
         ao_to_mo(denm[i],hso,e_vecs_so,temp2,nbasis);
         for(j=nstart[i]; j < nend[i] ; j++)
            elec2 += denm[i][ioff[j]+j];
         }

      elec = elec1+elec2;
      etot = elec+enuc;

      fprintf(outfile,"\n escf  = %20.10f\n",escf);
      fprintf(outfile," enuc  = %20.10f\n",enuc);
      fprintf(outfile," elec1 = %20.10f\n",elec1);
      fprintf(outfile," elec2 = %20.10f\n",elec2);
      fprintf(outfile," elec  = %20.10f\n",elec);
      fprintf(outfile," etot  = %20.10f\n",etot);

      free(temp);
      free_matrix(hso,nbasis);
      free_matrix(temp2,nbasis);
      free_matrix(denp,ntypes);
      free_matrix(denq,ntypes);
      free_matrix(denm,ntypes);
      rclose(itap31,3);
      }
#define EXTERN
#include "includes.h"
#include "common.h"

int ucmat()
{
   int i,j,ij,kl,ii;
   int iabc;
   int degeneracy=0;
   int first,last,num_vecs,num,ilast,vec;
   int core_left,core_needed,num_passes;
   double pval,qval,tdel,f;
   double *b0,**b,*del;
   double **denp,*denm,**denmt;
   double *dp_ij,*dp_kl;
   double *dm_ij,*dm_kl;
   double *esi1,*esi2,*esj1,*esj2;
   double **scr1,**scr2;
   struct c_pkints *c_pkpt;

   del = (double *) init_array(ndep);
   scr1 = (double **) init_matrix(nbasis,nbasis);
   scr2 = (double **) init_matrix(nbasis,nbasis);
   denm = (double *) init_array(ntri);

   core_left = MAX_WORDS-2*nbasis*nind-2*ntri-ndep-2*nbasis*nbasis;
   core_needed = 3*natom3x*ntri;
   if(core_needed < core_left) num_vecs=natom3x;
   else {
      num_passes = core_needed/core_left+1;
      num_vecs = natom3x/num_passes+1;
      }
   if(num_vecs <= 0) num_vecs=1;
   num_vecs = MIN0(num_vecs,natom3x);

   fprintf(outfile,"\nallocating %d vectors with %d words in ucmat\n",
          num_vecs,3*ntri*num_vecs);
   fflush(outfile);

   denp = (double **) init_matrix(ntri,num_vecs);
   denmt = (double **) init_matrix(ntri,num_vecs);
   b = (double **) init_matrix(num_vecs,ntri);

   srew(itap44);

   first = -num_vecs;
   last=0;
   do {
      first += num_vecs;
      last += num_vecs;
      last = MIN0(last,natom3x);

      zero_mat(denp,ntri,num_vecs);
      zero_mat(denmt,ntri,num_vecs);

      for(vec=first,iabc=0; vec < last ; vec++,iabc++) {
         rread(itap44,b[iabc],sizeof(double)*ntri,ba_loc[vec]);

         if(print > 2) {
            fprintf(outfile,"\nb0 iabc = %5d\n",vec);
            print_array(b[iabc],nbasis,outfile);
            }
         }

/* form density-like matrix in so basis */

      for(i=ij=0; i < nbasis ; i++) {
         for(j=0; j <= i ; j++,ij++) {
            esi1=so_vecs_k[i];
            esi2=so_vecs_l[i];
            esj1=so_vecs_l[j];
            esj2=so_vecs_k[j];
            for(ii=0; ii < nind ; ii++,esi1++,esi2++,esj1++,esj2++) {
               kl=indep[ii].ij;
               f = *esi1 * *esj1 + *esi2 * *esj2;
               if(f) {
                  f *= 2.0;
                  dp_ij=denp[ij];
                  for(vec=first,iabc=0; vec < last ; vec++,iabc++,dp_ij++)
                     *dp_ij += f*b[iabc][kl];
                  }
               }
            }
         }

      for(i=ij=0; i < nbasis ; i++)
         for(j=0; j <= i ; j++,ij++)
            for(vec=first,iabc=0; vec < last ; vec++,iabc++)
               denp[ij][iabc] = (i == j) ? denp[ij][iabc] : 2.0*denp[ij][iabc];

/* for half-transformed density matrix */

      srew(itap37);

      do {
         sread(itap37,c_pkbuf,sizeof(struct c_pkints)*maxbuf);
         num = (c_pkbuf[0].ij % (maxbuf+1));
         ilast = c_pkbuf[0].kl % (maxbuf+1);
         c_pkbuf[0].ij /= (maxbuf+1);
         c_pkbuf[0].kl /= (maxbuf+1);

         c_pkpt = c_pkbuf;
         for (i=num; i ; i--,c_pkpt++) {
            ij = (*c_pkpt).ij;
            kl = (*c_pkpt).kl;
            pval = (*c_pkpt).pval;
            dm_ij = denmt[ij];
            dm_kl = denmt[kl];
            dp_ij = denp[ij];
            dp_kl = denp[kl];
            for(vec=first;vec < last;vec++,dp_ij++,dp_kl++,dm_ij++,dm_kl++) {
               *dm_ij += *dp_kl*pval;
               *dm_kl += *dp_ij*pval;
               }
            }
         } while(!ilast);

      for(ii=0; ii < ndep ; ii++) {
         i=depen[ii].ii;
         j=depen[ii].jj;
         tdel = e_vals[j]-e_vals[i];
         if(i==j) tdel=1.0;
         if(fabs(tdel) > 1.0e-8) del[ii]=1.0/tdel;
         else degeneracy++;
         }

      for(vec=first,iabc=0; vec < last ; vec++,iabc++) {
         for(ii=0; ii < ntri ; ii++)
            denm[ii]=denmt[ii][iabc];
         ao_to_mo(denm,scr1,e_vecs_so,scr2,nbasis);

         b0 = b[iabc];
         for(ii=0; ii < ndep ; ii++) {
            ij = depen[ii].ij;
            tdel = del[ii];
            if(fabs(tdel) > 10.0e-15) b0[ij] = tdel*(b0[ij]+denm[ij]);
            }
         rwrit(itap44,b[iabc],sizeof(double)*ntri,ba_loc[vec]);

         if(print > 2) {
            fprintf(outfile,"\nb0 in ucmat iabc = %5d\n",vec);
            print_array(b[iabc],nbasis,outfile);
            }
         }
      } while(last != natom3x);

      free_matrix(scr1,nbasis);
      free_matrix(scr2,nbasis);
      free(del);
      free(denm);
      free_matrix(denp,ntri);
      free_matrix(denmt,ntri);
      free_matrix(b,num_vecs);

      return(degeneracy);
      }
#define EXTERN
#include "includes.h"
#include "common.h"

init_master()
   {
      int i,j,ij;
      int ii,jj;
      int ntri2,ntril,nbasql,n3trl,n3qrl;
      int ipara[1024];
      double rpara[1024];

      nsect=1024;
      maxbuf=8192;

      itap40=40;
      rfile(itap40);

      block_locs = (int *) init_array(1024/2);
      rread(itap40,block_locs,sizeof(int)*nsect,1);

      ntri2 = block_locs[13+nsect/2];
      ntri = ntri2/2;
      natom = block_locs[7+nsect/2];
      natom /= 8;
      nbasis = block_locs[5+nsect/2];

      ntril = (2*ntri-1)/nsect + 1;
      nbasql = (2*nbasis*nbasis-1)/nsect + 1;

      mread(ipara,1);
      mread(rpara,2);

      nc = ipara[6];
      no = ipara[7];
      nocc = ipara[8];
      iopen = ipara[5];
      natom3 = ipara[16];
      natom3x = (dipole) ? natom3+3 : natom3;
      n_so_typs = ipara[12];
      ntypes = ipara[17];
      ntype1 = ntypes+1;

      n3trl = natom3x*ntril;
      n3qrl = natom3x*nbasql;

      enuc = rpara[0];
      escf = rpara[1];

      if(iopen) 
         o_pkbuf = (struct o_pkints *) malloc(sizeof(struct o_pkints)*maxbuf);
      else
         c_pkbuf = (struct c_pkints *) malloc(sizeof(struct c_pkints)*maxbuf);

/* calculate some pointers */

      for (i=0; i < natom3x ; i++) {
         sa_loc[i] = i*ntril+1;
         ha_loc[i] = i*ntril+n3trl+1;
         fa_loc[i] = i*ntril+n3trl+n3trl+1;
         ea_loc[i] = i*nbasql+n3trl+n3trl+n3trl+1;
         ba_loc[i] = i*ntril+n3trl+n3trl+n3trl+n3qrl+1;
         ua_loc[i] = i*nbasql+n3trl+n3trl+n3trl+n3qrl+n3trl+1;
         }

      for(i=0; i < 10 ; i++) {
         focc[i] = rpara[i+40];
         nsorb[i] = ipara[40+i];
         }

      nstart[0] = 0;
      nend[0] = nsorb[0];
      for(i=1; i <= ntypes ; i++) {
         nstart[i] = nend[i-1];
         nend[i] = nstart[i]+nsorb[i];
         }

      for(i=0; i <= ntypes ; i++)
         for(j=nstart[i]; j < nend[i] ; j++)
            motyp[j] = i;

      for(i=1,ij=0; i <= ntypes ; i++)
         for(j=0; j < i ; j++)
            for(ii=nstart[i]; ii < nend[i] ; ii++)
               for(jj=nstart[j]; jj < nend[j] ; jj++,ij++) 
      nind = ij+1;

      indep = (struct ind_pairs *) malloc(sizeof(struct ind_pairs)*nind);
      for(i=1,ij=0; i <= ntypes ; i++)
         for(j=0; j < i ; j++)
            for(ii=nstart[i]; ii < nend[i] ; ii++)
               for(jj=nstart[j]; jj < nend[j] ; jj++,ij++) {
                  indep[ij].ii = ii;
                  indep[ij].jj = jj;
                  indep[ij].ij = ioff[ii]+jj;
                  indep[ij].it = motyp[ii];
                  indep[ij].jt = motyp[jj];
                  }

      for(ii=ij=0; ii <= ntypes ; ii++)
         for(i=nstart[ii]; i < nend[ii] ; i++)
            for(j=nstart[ii]; j <= i ; j++,ij++)
      ndep = ij+1;
      if(!iopen || print) {
         depen = (struct dep_pairs *) malloc(sizeof(struct dep_pairs)*ndep);
         for(ii=ij=0; ii <= ntypes ; ii++)
            for(i=nstart[ii]; i < nend[ii] ; i++)
               for(j=nstart[ii]; j <= i ; j++,ij++) {
                  depen[ij].ii = i;
                  depen[ij].jj = j;
                  depen[ij].ij = ioff[i]+j;
                  }
         }

      if(print > 1) {
         fprintf(outfile,"\nnsorb nstart nend \n");
         for(i=0; i < 10 ; i++)
            fprintf(outfile,"%5d %5d %5d\n",nsorb[i],nstart[i],nend[i]);

         fprintf(outfile,"\nmotyp \n");
         for(i=0; i < nbasis ; i++)
            fprintf(outfile,"%5d \n",motyp[i]);
         
         fprintf(outfile,"\nnij1 nij2 kij1 kij2\n");
         for(i=0; i < nind ; i++)
            fprintf(outfile,"%5d %5d %5d %5d\n",
               indep[i].ii,indep[i].jj,depen[i].ii,depen[i].ii);
         }

/* calculate alpa and beta matrices */

      if(iopen) {
         alpa = (double **) init_matrix(ntype1,ntype1);
         beta = (double **) init_matrix(ntype1,ntype1);

         for(i=ij=0; i < ntypes ; i++)
            for(j=0; j <= i ; j++) {
               alpa[j][i] = alpa[i][j] = (1.0-rpara[10+ij])*focc[i]*focc[j]*0.5;
               beta[j][i] = beta[i][j] = -(1.0-rpara[25+ij])*focc[i]*focc[j]*0.25;
               ij++;
               }
         }

      
      }

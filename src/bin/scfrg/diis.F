      SUBROUTINE DIIS(FC,FO,C,FSAVE,ERROR,SMHALF,SINVSQ,T1,T2,BMAT,
     #                NUMSYM,OCC,C1,C2,
     #                DIISER,
     #                NNPBLK,NUMBLK,NSYM,IOPEN,NDIIS,NFOCK,IPRINT,IOUT)
C
C***PURPOSE: TO FORM THE DIIS ERROR VECTOR AND PERFORM THE DIIS
C            EXTRAPOLATION.  P. PULAY, J. OF COMP. CHEM. 3, 556-560,
C            (1982).
C
C
C            SOME EXPLANATION OF THE STORAGE IS NEEDED:
C            THE PROGRAM IS SET UP TO HOLD NDIIS ITERATIONS WORTH OF
C            ERROR AND FOCK MATRICES. MNDIIS POINTS TO THE OLDEST
C            ITERATION, MXDIIS TO THE NEWEST. IF MNDIIS IS LESS THAN
C            MXDIIS, ALL IS OBVIOUS, BUT IF MNDIIS IS GREATER THAN MXDII
C            THE STORED INFORMATION WRAPS AROUND AT MNDIIS. EG., IF
C            NDIIS=3, MNDIIS=2 AND MXDIIS=1, THE OLDEST INFORMATION
C            IS IN 2, THE NEXT OLDEST IN 3 AND THE NEWEST IN 1.
C
C PAUL SAXE                  8 NOVEMBER 1984           LANL
C
C      PWS MODIFIED TO BE USED WITH PITZER'S PROGRAM 27 NOV 1984  UCB.
C
      IMPLICIT INTEGER (A-Z)
C
      REAL*8 FC(NNPBLK),C(NUMBLK),FSAVE(NNPBLK,NFOCK,NDIIS)
      REAL*8 FO(NNPBLK),C1(NSYM),C2(NSYM)
      REAL*8 ERROR(NNPBLK,NDIIS),SMHALF(NNPBLK),SINVSQ(NUMBLK)
      REAL*8 T1(*),T2(*),BMAT(NDIIS,*)
      REAL*8 DIISER,DETCUT,DETERM,OCC(2,*),ERRCUT
      REAL*8 ASHIFO,DIISCT,AERRO,AFAC
CTJL
      COMMON /TJL/ ASHIFO,DIISCT,AERRO,AFAC
CTJL
      INTEGER NUMSYM(NSYM)
C
      DATA DETCUT /1.0D-20/
      DATA ERRCUT /1.0D-6/
CTJL  DATA DIISCT /1.0D+00/
      DATA MNDIIS /0/, MXDIIS /0/
C
CTJL  SAVE MNDIIS,MXDIIS
C
C     ----- STATEMENT FUNCTIONS -----
C
      OFFSET(I,J)=I*(I-1)/2+J
C
C     ----- BACK TRANSFORM OPEN SHELL FOCK MATRICES TO AO BASIS -----
C
CTJL  IF (IOPEN.NE.0) THEN
C        CALL TRNBLK(FC,C,T1,T2,NUMSYM,NSYM,NUMBLK,
C    #               NNPBLK,1)
C        CALL TRNBLK(FO,C,T1,T2,NUMSYM,NSYM,NUMBLK,
C    #               NNPBLK,1)
CTJL  END IF
C
C
C     ----- TRANSFORM THE FOCK MATRICES TO THE MO BASIS, TEMPORARILY
C           USING FSAVE TO HOLD THE TRANSFORMED MATRICES ------
C
C     WRITE(IOUT,333)
C 333 FORMAT(' DENSITY MATRIX ')
C     CALL BRINT(D,7,7,IOUT)
CP    WRITE(IOUT,334)
CP334 FORMAT(' FOCK MATRIX ')
CP    CALL BRINT(FC,7,7,IOUT)
CP    CALL BRINT(FO,7,7,IOUT)
      MXDIIS=MXDIIS+1
C     CALL VECOUT(C,T1,NUMBLK,1,NUMSYM,NSYM,IOUT)
      IF (MXDIIS.EQ.MNDIIS) MNDIIS=MNDIIS+1
      IF (MNDIIS.GT.NDIIS) MNDIIS=1
      IF (MNDIIS.LE.0) MNDIIS=1
      IF (MXDIIS.GT.NDIIS) THEN
         MXDIIS=1
         MNDIIS=2
      END IF
C
      CALL VMOVE(FSAVE(1,1,MXDIIS),FC,NNPBLK)
      IF (IOPEN.NE.0) CALL VMOVE(FSAVE(1,2,MXDIIS),FO,NNPBLK)
C     IF (NFOCK.EQ.1) GO TO 9876
C
CTJL  IF (IOPEN.EQ.0) THEN
      DO 1 I=1,NFOCK
CP    CALL BLKPRT(FSAVE(1,I,MXDIIS),NNPBLK,NUMSYM,NSYM,IOUT)
         CALL TRNBLK(FSAVE(1,I,MXDIIS),C,T1,T2,NUMSYM,NSYM,NUMBLK,
     #               NNPBLK,0)
C     WRITE (IOUT,9879) I
C9879 FORMAT (' %%%% MO FOCK MATRIX',I2)
C     CALL BLKPRT(FSAVE(1,I,MXDIIS),NNPBLK,NUMSYM,NSYM,IOUT)
    1 CONTINUE
CTJL  END IF
C
C     ----- FORM THE ERROR VECTOR IN THE MO BASIS -----
C
      CALL ZERO(ERROR(1,MXDIIS),NNPBLK)
      IF (IOPEN.EQ.0) THEN
C
C        ----- CLOSED-SHELL RHF -----
C
         PTTRI=0
         PTOCC=0
         DO 4 SYM=1,NSYM
            NUMS=NUMSYM(SYM)
            IF (NUMS.LE.0) GO TO 4
            NNPS=OFFSET(NUMS,NUMS)
            DO 3 I=1,NUMS
CTJL           IF (ABS(OCC(1,PTOCC+I)).GT.1.0D-06) GO TO 3
               IF (ABS(OCC(1,PTOCC+I)).GT.ERRCUT) GO TO 3
               IA=OFFSET(I,0)+PTTRI
               DO 2 J=1,NUMS
CTJL              IF (ABS(OCC(1,PTOCC+J)).LE.1.0D-06) GO TO 2
                  IF (ABS(OCC(1,PTOCC+J)).LE.ERRCUT) GO TO 2
                  IJ=IA+J
                  ERROR(IJ,MXDIIS)=FSAVE(IJ,1,MXDIIS)
    2          CONTINUE
    3       CONTINUE
            PTTRI=PTTRI+NNPS
            PTOCC=PTOCC+NUMS
    4    CONTINUE
C
C        ----- TRANSFER THE AO FOCK MATRIX TO FSAVE -----
C
         CALL VMOVE(FSAVE(1,1,MXDIIS),FC,NNPBLK)
C
      ELSE
C
C        ----- OPEN SHELL RHF -----
C
         PTTRI=0
         PTOCC=0
         DO 10 SYM=1,NSYM
            NUMS=NUMSYM(SYM)
            IF (NUMS.LE.0) GO TO 10
            NNPS=OFFSET(NUMS,NUMS)
            DO 6 I=1,NUMS
               IF (ABS(OCC(2,PTOCC+I)).LE.1.0D-06) GO TO 6
               IA=OFFSET(I,0)+PTTRI
               DO 5 J=1,NUMS
                  IF (ABS(OCC(1,PTOCC+J)).LE.1.0D-06) GO TO 5
CP      WRITE (IOUT,76) I,J
CP 76   FORMAT(' HO--DO ',2I3)
                  IJ=IA+J
CC                ERROR(IJ,MXDIIS)=C1(SYM)*FSAVE(IJ,1,MXDIIS)-
CC   #                             C2(SYM)*FSAVE(IJ,2,MXDIIS)
                  ERROR(IJ,MXDIIS)=FSAVE(IJ,1,MXDIIS)-
     #                             FSAVE(IJ,2,MXDIIS)/2
    5          CONTINUE
    6       CONTINUE
            DO 9 I=1,NUMS
               IF (ABS(OCC(1,PTOCC+I)).GT.1.0D-06.OR.
     #         ABS(OCC(2,PTOCC+I)).GT.1.0D-06) GO TO 9
               IA=OFFSET(I,0)+PTTRI
               DO 7 J=1,NUMS
                  IF (ABS(OCC(1,PTOCC+J)).LE.1.0D-06) GO TO 7
                  IJ=IA+J
CP    WRITE (IOUT,77) I,J
CP 77 FORMAT(' VIR--DO ',2I3)
CC                ERROR(IJ,MXDIIS)=C1(SYM)*FSAVE(IJ,1,MXDIIS)
                  ERROR(IJ,MXDIIS)=FSAVE(IJ,1,MXDIIS)
    7          CONTINUE
               DO 8 J=1,NUMS
                  IF (ABS(OCC(2,PTOCC+J)).LE.1.0D-06) GO TO 8
                  IJ=IA+J
CP    WRITE (IOUT,78) I,J
CP 78 FORMAT (' VIR--HO',2I3)
CC                ERROR(IJ,MXDIIS)=C2(SYM)*FSAVE(IJ,2,MXDIIS)
                  ERROR(IJ,MXDIIS)=FSAVE(IJ,2,MXDIIS)/2
    8          CONTINUE
    9       CONTINUE
            PTTRI=PTTRI+NNPS
            PTOCC=PTOCC+NUMS
   10    CONTINUE
C
C        ----- TRANSFER THE AO FOCK MATRICES TO FSAVE -----
C
         CALL VMOVE(FSAVE(1,1,MXDIIS),FC,NNPBLK)
         CALL VMOVE(FSAVE(1,2,MXDIIS),FO,NNPBLK)
C
      END IF
C
C     ----- TRANSFORM THE ERROR VECTOR TO THE AO BASIS -----
C
CP    CALL BLKPRT(ERROR(1,MXDIIS),NNPBLK,NUMSYM,NSYM,IOUT)
      CALL TRNBLK(ERROR(1,MXDIIS),C,T1,T2,NUMSYM,NSYM,NUMBLK,NNPBLK,
     #            1)
C
C     ----- SQUARE UP THE S**(-1/2) MATRIX -----
C
      PTTRI=1
      PTSQR=1
      DO 11 SYM=1,NSYM
         NUMS=NUMSYM(SYM)
         IF (NUMS.LE.0) GO TO 11
         NNPS=OFFSET(NUMS,NUMS)
         CALL TRTOSQ(SINVSQ(PTSQR),SMHALF(PTTRI),NUMS,NNPS)
         PTTRI=PTTRI+NNPS
         PTSQR=PTSQR+NUMS**2
   11 CONTINUE
C
C     ----- AND TRANSFORM THE ERROR VECTOR TO THE S**(-1/2) BASIS -----
C
      CALL TRNBLK(ERROR(1,MXDIIS),SINVSQ,T1,T2,NUMSYM,NSYM,NUMBLK,
     #            NNPBLK,0)
CP    WRITE (IOUT,12346)
CP346 FORMAT(' ERROR VECTOR IN THE S**(-1/2) BASIS')
CP    CALL BLKPRT(ERROR(1,MXDIIS),NNPBLK,NUMSYM,NSYM,IOUT)
C
C     ----- FIND THE MAXIMUM ELEMENT OF THE ERROR VECTOR -----
C
      DIISER=0.0D+00
      DO 12 I=1,NNPBLK
         DIISER=MAX(DIISER,ABS(ERROR(I,MXDIIS)))
   12 CONTINUE
CTJL
      IF(DIISER.GE.DIISCT.AND.IOPEN.NE.0) RETURN
CTJL
C
C     ----- FORM THE SMALL MATRIX AND SOLVE THE DIIS EQUATIONS -----
C
   13 CONTINUE
C
C        ----- WORK OUT HOW MANY DIIS ITERATIONS THERE ARE -----
C
         IF (MNDIIS.LE.MXDIIS) THEN
            NITER=MXDIIS-MNDIIS+1
         ELSE
            NITER=NDIIS-MNDIIS+MXDIIS+1
         END IF
         N=NITER+1
         M=NITER+2
         IF (NITER.LE.1) GO TO 14
         CALL SOLVED(FSAVE,ERROR,FC,FO,BMAT,NNPBLK,NFOCK,NDIIS,N,M,
     #               MNDIIS,MXDIIS,DETERM,DETCUT,IPRINT,IOUT)
C
C        ----- IF HAD PROBLEMS SOLVING THE EQUATIONS, THROW OUT OLDEST
C              FOCK MATRIX -----
C
         IF (ABS(DETERM).LT.DETCUT) THEN
            IF (MNDIIS.EQ.MXDIIS) STOP 14
            MNDIIS=MNDIIS+1
           IF (MNDIIS.GT.NDIIS) MNDIIS=1
            GO TO 13
         END IF
   14 CONTINUE
C
C        ------ TRANSFORM OPEN SHELL FOCK MATRICES TO MO BASIS -----
CTJL  IF (IOPEN.NE.0) THEN
C        CALL TRNBLK(FC,C,T1,T2,NUMSYM,NSYM,NUMBLK,
C    #               NNPBLK,0)
C        CALL TRNBLK(FO,C,T1,T2,NUMSYM,NSYM,NUMBLK,
C    #               NNPBLK,0)
CTJL  END IF
C
      RETURN
      END
